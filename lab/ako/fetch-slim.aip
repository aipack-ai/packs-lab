# Before All

```lua
local p_utils = require("prompt_utils")
local f_utils = require("fetch_utils")

-- input is nil or the config_path
local init_res = p_utils.init_config(input)

if init_res.type == "message" then
  print(init_res.data)
  return
end

-- Assuming type = "config"
local config = init_res.data

local settings = p_utils.build_settings(config)

-- local CONFIG = SETTINGS.config

local FIRST_PAGE     = config.first_page
-- local BASE_URL       = CONFIG.base_url
-- local FILTER_PATH    = CONFIG.filter_path
-- local MAX_PAGES      = CONFIG.max_pages

local has_exclude_globs  = config.fetch_exclude_globs and next(config.fetch_exclude_globs) ~= nil 

local fetch_ctx = {
  has_exclude_globs = has_exclude_globs, -- probably need to be in config
  settings          = settings,
  page_counter      = 0,
  total_orig_size   = 0,
  total_slim_size   = 0,
  total_md_raw_size = 0,
}

-- === fetch_ctx methods

-- where path is without extension (e.g.,  path_obj.dir .. "/" .. stem)
function fetch_ctx:path_0_orig_html(path) 
  path = path_to_base_path(path)
  return self.settings.dir_0_original .. "/" .. path .. ".html"
end

-- where path is without extension (e.g.,  path_obj.dir .. "/" .. stem)
function fetch_ctx:path_1_slim_html(path) 
  path = path_to_base_path(path)
  return self.settings.dir_1_slim_html .. "/" .. path .. ".html"
end  

-- where path is without extension (e.g.,  path_obj.dir .. "/" .. stem)
function fetch_ctx:path_2_raw_md(path) 
  path = path_to_base_path(path)
  return self.settings.dir_2_raw_md .. "/" .. path .. ".md"
end  

-- return path without extension
function path_to_base_path(path)
  local path_obj  = aip.path.parse(path)
  local stem      = path_obj.stem
  if stem == "" then
    stem = "index"
  end
  -- TODO: if dir empty, then no need to have / prefix
  local base_path = path_obj.dir .. "/" .. stem
  return base_path
end

-- === /fetch_ctx methods

-- WEB processing
if fetch_ctx.settings.src_type == "web" then
  -- Map of all of the page_url already processed
  -- NOTE: this also contain the excluded from globs (so that we do not double print)
  local page_urls_map = {}

  -- Process initial page, links in the page
  local links       = f_utils.process_url(FIRST_PAGE, fetch_ctx).links
  page_urls_map[FIRST_PAGE] = true

  -- Process the links and get a links_queue
  local links_queue = f_utils.process_links(links, page_urls_map, FIRST_PAGE, fetch_ctx)

  -- Final process of each links in the links_queue
  -- Note: We do not go recursive, just one level down
  for i, item in ipairs(links_queue) do
    f_utils.process_links(item.links, page_urls_map, item.page_url, fetch_ctx)
  end

-- FILE processing
elseif fetch_ctx.settings.src_type == "file" then
  local config    = fetch_ctx.settings.config
  local base_dir  = config.base_dir
  local max_pages = config.max_pages
  local src_globs = config.base_dir .. "/" .. config.globs

  local all_files = aip.file.list(src_globs)

  for i, file in ipairs(all_files) do
    if fetch_ctx.page_counter >= max_pages then
      break
    end

    local rel_path = aip.path.diff(file.path, base_dir)
    local raw_md_path = fetch_ctx:path_2_raw_md(rel_path)
    
    if not aip.path.exists(raw_md_path) then 
      f_utils.process_file(file, fetch_ctx)
    end
    
    -- print(base_path)
    -- local html_slim_file = aip.file.save_html_to_slim(file.path, fetch_ctx:path_1_slim_html(base_path))
    -- fetch_ctx.page_counter = fetch_ctx.page_counter + 1
    -- fetch_ctx.total_md_raw_size = fetch_ctx.total_md_raw_size + html_slim_file.size
  end
  
  -- print(#all_files)
  -- return aip.flow.skip("src_type '" .. fetch_ctx.settings.src_type .. "' not supported")
else 
  return aip.flow.skip("src_type '" .. fetch_ctx.settings.src_type .. "' not supported")
end

local final_msg = "✅ Slim completed. " .. fetch_ctx.page_counter .. " files processed."
local sizes_msg = aip.text.format_size(fetch_ctx.total_orig_size) .. " ➜ " .. aip.text.format_size(fetch_ctx.total_md_raw_size)
sizes_msg = aip.text.trim(sizes_msg)
final_msg = final_msg .. "\n   " .. sizes_msg
aip.run.pin("process", 1, {label = "      DONE:", content = final_msg})

-- Here we make sure the inputs is nil, since it was not for the tasks but for the before_all
return aip.flow.before_all_response({
  inputs     = {},
  before_all = {
    num_of_files          = fetch_ctx.page_counter,
    orig_html_total_size  = fetch_ctx.total_orig_size,
    raw_md_total_size     = fetch_ctx.total_md_raw_size,
  }
})
```

# After All

```lua

return before_all

```